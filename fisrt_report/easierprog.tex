\section{Simulator for the C++ program}

To help and create a faster development for the Sailing Robot project the creation of a simulator would be useful, in the testing of the \gls{C++} program used to control the boat. 
There is some simulator to test the algorithm and Matlab but the conversion from Matlab to C++ can induce some bugs that were not yet easy to identify.
The current design of the code at the time of the creation of the simulator was too complicated and old to be able to simply implement the simulation in the code itself, therefore the easiest way to do it was to pre-empt the connection to the sensor needed to drive the boat.

\begin{figure}[H]
\centering
\psscalebox{0.5 0.5} % Change this value to rescale the drawing.
{
\input{model_com}
}
\caption{Data transfer model of the boat.}
\label{fig:model_boat_}
\end{figure}

As seen on~\ref{fig:model_boat_}, the data goes from and to the main program regulating the boat via three different mean of communication.
The sensor data comes from serial ports \gls{RS232} and \gls{i2c} communication and the program send data to the remote web server via \gls{TCPIP}. The simulator only need to deal with two of the communication path, \gls{i2c} and serial communication, as the web server will always be available. 

\gls{linux} allow to create easily many virtual serial ports via programming but it is no possible to do the same for \gls{i2c} communication. To remediate at this problem the solution is to bypass function used by the main program to discuss with the I$^2$C bus. The program use a dynamic library (not compiled inside the program  and loaded in memory at runtime), functions can be overloaded if other functions with the same prototype (same name, same input parameters and same output) are loaded before. Then those function will communicate with the exterior of the program  with \gls{sharedmemory}.

\begin{figure}[H]
\centering
\psscalebox{0.5 0.5} % Change this value to rescale the drawing.
{
\input{model_boat_plus_sim}
}
\caption{Data transfer model of the boat with simulator.}
\label{fig:model_boat_sim}
\end{figure}

The implementation of the simulator need a program on the same computing unit as the main program to be able to use virtual serial ports and \gls{sharedmemory}, this side program is used as a proxy for the simulator, the communication is via \gls{TCPIP} to allow easy configuration (i.e.\ changing parameters of the simulation on a computer and the main program running on the embedded computer allowing to test the code directly on the computer that will be sailing).
The data transferred between the simulator and the side program are raw values, the side program will 
then transform the data for serial port as the real sensor messages, e.g.\ \gls{NMEA} messages for the GPS and 
wind sensor.

The main program was then refactor to a node and message program, meaning each sensor is a node sending messages to the node that will compute the orders to give to the actuators. The program created before work without changes on this model, but to follow the model of the program a simulation as been created , the node directly send the messages inside the program and is still discussing with the simulator with \gls{TCPIP}.
The advantage of this simulation is a simpler initialisation but the first implementation still as some advantage such as allowing testing different preprocessing of data (filters).

In the end this simulator is useful as it help the programmer testing quickly the code and the implementation of the algorithm without doing real test.


\section{Work method}

\section{Smith predictor}

The sailboat have many thing that will delay the effect of the control,
reason is the lag generated by the time taken by the actuators to take their positions

